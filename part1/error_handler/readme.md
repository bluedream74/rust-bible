# panic!不可恢复的错误
    panic!时进程默认开始展开（unwinding）、回溯栈并清理函数据
    如果希望二进制文档尽量小，可以选择“终止（abort）”，
    此时进程内存由操作系统进行清理

    展开：展开是从其遇到的每个函数的堆栈存储器中清除数据的过程。
    但是, 展开过程需要大量工作。展开的替代方法是中止
    终止：是在不清除堆栈存储器中数据的情况下结束程序的过程。
    操作系统将删除数据。如果我们从平缓切换到终止, 那么我们需要添加以下语句：
    [profile]
    panic='abort'
    
    [profile.release]
    panic='abort'

# RUST_BACKTRACE 可以追踪堆栈信息
    设置 RUST_BACKTRACE 环境变量来得到一个 backtrace backtrace 
    是一个执行到目前位置所有被调 用的函数的列表。Rust 的 backtrace 
    跟其他语言中的一样：阅读 backtrace 的关键是从头开始读直到发现你编写的文件

# rust错误处理方式
    关于panic！和 Result<T,E> 错误传播处理的选择:
        对于一些启动或读取配置文件，这种可以panic!,程序必须终止的时候
        对于一些错误处理可交给上游业务方处理的话，就建议使用Result + ?错误传播的方式，让调用者自己来决定
        对于不会发生的错误，可以使用unwrap(),expect("xxx")来处理
        panic!,unwrap(),expect这三个，如果在多个线程中处理，
        仅仅只会影响当前线程，不会发生跨线程的panic

# rust错误的小结
    Rust 的错误处理功能被设计为帮助你编写更加健壮的代码。
    panic! 宏代表一个程序无法处理的状态，并停止执行而不是使用无效或不正确的值继续处理。
    Rust 类型系统的 Result 枚举代表操作可能会在一种可以恢复的情况下失败。
    可以使 用 Result 来告诉代码调用者他需要处理潜在的成功或失败。
    在适当的场景使用 panic! 和 Result 将会使你的代码在面对无处不在的错误时显得更加可靠。
