# rust内存回收策略

在有 垃圾回收（garbage collector，GC）的语言中， GC 记录并清除不再使用的内存，
而我们并不需要关心它。在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，
跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。
如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 allocate 
配对一个 free。

Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放

# copy trait
    如果一个类型实现了Copy trait，那么一个旧的变量在它赋值给其他变量后仍然可用。
    rust不允许自身或其任何部分实现了drop tait的类型使用Copy trait
    copy类型的赋值会复制值，而不是发生move转移，原来的那个变量继续可以用。
    标准的copy类型：
    整数，布尔bool,浮点类型，字符char类型，元组（当且仅当其包含的类型都实现了copy trait,比如(i32,String)就不是)
    固定大小的数组

    对于自定义的类型，如果设计为Copy trait后，实际上是一个庄严的承诺，如果后面还需要改成非copy，那所有的代码都需重写


# move
    rust所有转移本质上字节到字节的浅复制，会导致原来的变量未初始化。

# 引用的规则

让我们概括一下之前对引用的讨论：

    在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
    引用必须总是有效的。