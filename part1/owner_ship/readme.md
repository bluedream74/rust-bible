# 所有权和借用
    
    Rust之所以能成为万众瞩目的语言，就是因为其内存安全性。
    在以往，内存安全几乎都是通过GC的方式实现，但是GC会引来性能、
    内存占用以及Stop the world等问题，在高性能场景和系统编程上是不可接受的，
    因此Rust采用了与(错)众(误)不(之)同(源)的方式：所有权系统

# 所有权
    所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，
    如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。
    在计算机语言不断演变过程中，出现了三种流派：
        垃圾回收机制(GC)，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
        手动管理内存的分配和释放, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
        通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查
    
    其中Rust选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，
    不会有任何性能上的损失。

# 所有权与堆栈

当你的代码调用一个函数时，传递给函数的参数(包括可能指向堆上数据的指针和函数的局部变量)依次被压入栈中，
当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，
否则堆上的数据将产生内存泄漏 - 这些数据将永远无法被回收。这就是Rust所有权系统为我们提供的强大保障。

对于其他很多编程语言，你确实无需理解堆栈的原理，但是在Rust中，明白堆栈的原理，
对于我们理解所有权的工作原理会有很大的帮助.

# rust所有权原则

理解了堆栈，接下来看一下关于所有权的规则，首先请谨记以下规则：

        Rust中每一个值都有且只有一个所有者(变量)
        当所有者(变量)离开作用域范围时，这个值将被丢弃(free)
            主要因为当变量离开作用域后，Rust会自动调用 drop 函数并清理变量的堆内存
        因此，Rust这样解决问题：当s1赋予s2后，Rust认为s1不再有效，因此也无需在s1离开作用域后drop任何东西，
        这就是把所有权从s1转移给了s2，s1在被赋予s2后就马上失效了.
        再来看看，在所有权转移后再来使用旧的所有者，会发生什么：
```rust
        let s1 = String::from("hello");
        let s2 = s1; // s1已经把所有权move到了s2,这个时候s1就是未初始化的状态了，就自动free
        println!("{}, world!", s1);
        // = note: move occurs because `s1` has type `std::string::String`, 
        // which does not implement the `Copy` trait
```

# 变量作用域
    变量作用域

作用域是一个变量在程序中有效的范围, 假如有这样一个变量：

```rust
let s = "hello"
```

变量s绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。 
s变量从声明的点开始直到当前作用域的结束都是有效的：
```rust
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从此处起，s 是有效的
    // 使用 s
}                      // 此作用域已结束，s不再有效
```
简而言之，s从创建伊始就开始有效，然后有效期持续到它离开作用域为止， 
可以看出，就作用域来说，Rust语言跟其他编程语言没有区别。
```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作

// 同样的，函数返回值也有所有权，例如:
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
    // 移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
    // takes_and_gives_back 中,
    // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
// 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 将返回值移动给
    // 调用它的函数

    let some_string = String::from("hello"); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
```

# String 类型
    字符串字面值let s ="hello"，s是被硬编码进程序里的字符串值（类型为&str）。
    字符串字面值是很方便的，但是它并不适用于所有场景。原因有二：

    字符串字面值是不可变的，因为被硬编码到程序代码中
    并非所有字符串的值都能在编写代码时得知

    例如，字符串是需要程序运行时，通过用户动态输入然后存储在内存中的，
    这种情况，字符串字面值就完全无用武之地。 为此，Rust为我们提供动态字符串类型: String, 
    该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。
    可以使用下面的方法基于字符串字面量来创建String类型:

```rust
let s = String::from("hello");
```
::是一种调用操作符，这里表示调用String中的from方法，因为String存储在堆上是动态的

String类型是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，
其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存，至于长度和容量，
如果你有Go语言的经验，这里就很好理解：容量是堆内存分配空间的大小，长度是目前已经使用的大小.

# Copy特征
    Rust 有一个叫做 Copy的特征，可以用在类似整型这样在栈中存储的类型。
    如果一个类型拥有 Copy特征，一个旧的变量在被赋值给其他变量后仍然可用。

    那么什么类型是可Copy 的呢？可以查看给定类型的文档来确认，
    不过作为一个通用的规则:
    任何基本类型的组合可以是 Copy 的，
    不需要分配内存或某种形式资源的类型是 Copy 的。如下是一些 Copy 的类型：

    所有整数类型，比如 u32。
    布尔类型，bool，它的值是 true 和 false。
    所有浮点数类型，比如 f64。
    字符类型，char。
    元组，当且仅当其包含的类型也都是 Copy 的时候。
    比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。



