# rust并发模型
    起初，Rust 团队认为确保内存安全和防止并发问题是两个分别需要不同方法应对的挑战。
    随着时间的推移，团队发现所有权和类型系统是一系列解决内存安全和并发问题的强有力的工具！
    通过利用所有权和类型检查，在 Rust 中很多并发错误都是 编译时 错误，而非运行时错误。
    因此，相比花费大量时间尝试重现运行时并发 bug 出现的特定情况，
    Rust 会拒绝编译不正确的代码并提供解释问题的错误信息。
    因此，你可以在开发时修复代码，而不是在部署到生产环境后修复代码。
    我们给 Rust 的这一部分起了一个绰号 无畏并发（fearless concurrency）。
    无畏并发令你的代码免于出现诡异的 bug 并可以轻松重构且无需担心会引入新的 bug。

    很多语言所提供的处理并发问题的解决方法都非常有特色。例如，Erlang 有着优雅的消息传递并发功能，
    但只有模糊不清的在线程间共享状态的方法。对于高级语言来说，只实现可能解决方案的子集是一个合理的策略，
    因为高级语言所许诺的价值来源于牺牲一些控制来换取抽象。然而对于底层语言则期望提供在任何给定的情况下
    有着最高的性能且对硬件有更少的抽象。
    因此，Rust 提供了多种工具，以符合实际情况和需求的方式来为问题建模。

    Rust 标准库只提供了 1:1 线程模型实现。由于 Rust 是较为底层的语言，
    如果你愿意牺牲性能来换取的抽象，以获得对线程运行更精细的控制及更低的
    上下文切换成本，你可以使用实现了 M:N 线程模型的 crate。

    在大部分现代操作系统中，执行中程序的代码运行于一个 进程（process）中，
    操作系统则负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分。
    这个运行这些独立部分的功能被称为 线程（threads）。
    将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，
    不过这也会增加复杂性。因为线程是同时运行的，所以无法预先保证不同线程中的
    代码的执行顺序。这会导致诸如此类的问题：
    1.竞争状态（Race conditions），多个线程以不一致的顺序访问数据或资源
    2.死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，
    这会阻止它们继续运行
    3.只会发生在特定情况且难以稳定重现和修复的 bug

    Rust 尝试缓和使用线程的负面影响。不过在多线程上下文中编程仍需格外小心，
    同时其所要求的代码结构也不同于运行于单线程的程序。

    编程语言有一些不同的方法来实现线程。很多操作系统提供了创建新线程的 API。
    这种由编程语言调用操作系统 API 创建线程的模型有时被称为 1:1，一个 OS 线程对应一个语言线程。
    很多编程语言提供了自己特殊的线程实现。
    编程语言提供的线程被称为 绿色（green）线程，使用绿色线程的语言会在不同数量的 OS 
    线程的上下文中执行它们。
    为此，绿色线程模式被称为 M:N 模型：M 个绿色线程对应 N 个 OS 线程，这里 M 和 N 不必相同。
    每一个模型都有其优势和取舍。
    
    对于 Rust 来说最重要的取舍是运行时支持。运行时（Runtime）是一个令人迷惑的概念，其在不同上下文中可能有不同的含义。
    在当前上下文中，运行时 代表二进制文件中包含的由语言自身提供的代码。
    这些代码根据语言的不同可大可小，不过任何非汇编语言都会有一定数量的运行时代码。
    为此，通常人们说一个语言 “没有运行时”，一般意味着 “小运行时”。
    更小的运行时拥有更少的功能不过其优势在于更小的二进制输出，这使其易于在更多上下文中与其他语言相结合。
    虽然很多语言觉得增加运行时来换取更多功能没有什么问题，但是 Rust 需要做到几乎没有运行时，
    同时为了保持高性能必需能够调用 C 语言，这点也是不能妥协的。

    绿色线程的 M:N 模型需要更大的语言运行时来管理这些线程。
    因此，Rust 标准库只提供了 1:1 线程模型实现。
    由于 Rust 是较为底层的语言，如果你愿意牺牲性能来换取的抽象，
    以获得对线程运行更精细的控制及更低的上下文切换成本，
    你可以使用实现了 M:N 线程模型的 crate。
