# 数据类型
    类型分为：基本数据类型和复合类型

    基本数据类型：
        数值类型: 有符号整数 (i8, i16, i32, i64, isize)
                无符号整数 (u8, u16, u32, u64, usize) 
                浮点数 (f32, f64)、以及有理数、复数
        字符串：字符串字面量、字符串切片&str和堆分配字符串String
        布尔类型： true和false
        字符类型: 表示单个Unicode字符，存储为4个字节,比如说'a','b'
        元类型: 即()，其唯一的值也是()
        元类型

        元类型就是()，对，你没看错，就是()，唯一的值也是()
        没错，main函数就返回这个元类型()，你不能说main函数无返回值，
        因为没有返回值的函数在Rust中是有单独的定义的：发散函数,顾名思义，无法收敛的函数.
        例如常见的println!()的返回值也是元类型()。

# 语句和表达式
    对于Rust语言而言，这种基于语句和表达式的方式是非常重要的，你需要能明确的区分这两个概念, 
    但是对于很多其它语言而言，这两个往往无需区分。
    基于表达式是函数式语言的重要特征，表达式总要返回值。
    表达式会进行求值，然后返回一个值

# 类型推导

    Rust是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，
    但这不意味着你需要为每个变量指定类型，因为Rust编译器很聪明，
    它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型，
    同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注

# fn函数定义
    函数要点
    函数名和变量名使用蛇形命名法(snake case)，例如fn add_two() -> {}
    函数的位置可以随便放，Rust不关心我们在哪里定义了函数，只要有定义即可
    每个函数参数都需要标注类型
```rust
// 定义函数,->表示返回的标志，返回结果是一个i32类型
// x，y后面的: 接着指定类型
fn add(x: i32, y: i32) -> i32 {
    x + y // 这里rust中可以省略return直接将表达式作为结果返回
}

// 无返回值的函数定义
fn another_fn(x: i32) {
    println!("x = {x}");
}
// 元类型()，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：

// 函数没有返回值，那么返回一个()
// 通过;结尾的表达式返回一个()

// 永不返回任何东西
fn dead_end() -> ! {
    panic!("你已经到了穷途末路，崩溃吧！");
}

```

