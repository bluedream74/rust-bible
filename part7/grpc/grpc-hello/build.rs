use protoc_rust_grpc::Codegen;
use std::ffi::OsStr;
use std::fs;
use std::io::Write;
use std::path::Path;

// 如果通过shell 生成mod.rs需要打开下面的注释
// use std::process::Command;

fn main() {
    // 1.读取proto目录下的*.proto
    let mut file_list = Vec::new();
    let lists = Path::new("proto")
        .read_dir()
        .expect("read proto dir failed");
    for entry_path in lists {
        if entry_path.as_ref().unwrap().path().is_file() {
            file_list.push(entry_path.unwrap().path())
        }
    }

    // 创建目录
    let _ = fs::create_dir("src/rust_grpc");

    // 2.生成rust grpc代码
    Codegen::new()
        .out_dir("src/rust_grpc")
        .includes(&["proto"])
        .inputs(&file_list)
        .rust_protobuf(true)
        .run()
        .expect("protoc-rust-grpc");

    // 3.生成mod.rs文件
    // Command::new("sh")
    //     .arg("bin/rust-gen.sh")
    //     .output()
    //     .expect("sh exec error!");

    // 用下面的rust方式生成mod.rs
    let proto_ext = OsStr::new("proto");
    let ext: Option<&OsStr> = Some(&proto_ext);
    let mut mod_file = fs::OpenOptions::new()
        .write(true)
        .create(true)
        .open("src/rust_grpc/mod.rs")
        .expect("create mod.rs failed");
    let header = String::from("// @generated by protoc-gen-rust.Do not edit it!!!\n");
    let _ = mod_file.write(header.as_bytes());
    for file in &file_list.iter().next() {
        if file.extension().eq(&ext) {
            // 拓展名是proto的写入mod.rs中
            if let Some(file) = file.file_name() {
                let filename = file.to_str().unwrap();
                let filename = filename.replace(".proto", "");
                println!("current filename: {}", filename);
                let _ = mod_file.write(
                    format!("pub mod {};\npub mod {}_grpc;\n", filename, filename).as_bytes(),
                );
            }
        }
    }
}
