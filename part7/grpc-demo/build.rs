use std::ffi::OsStr;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // tonic_build::compile_protos("proto/hello.proto")?;

    // 推荐下面的方式生成grpc rust代码
    // 1.读取proto目录下的*.proto
    let mut file_list = Vec::new();
    let lists = Path::new("proto")
        .read_dir()
        .expect("read proto dir failed");
    for entry_path in lists {
        if entry_path.as_ref().unwrap().path().is_file() {
            file_list.push(entry_path.unwrap().path())
        }
    }

    // 创建目录
    let _ = fs::create_dir("src/rust_grpc");

    // 2.生成rust grpc代码
    // 指定rust grpc 代码生成的目录
    tonic_build::configure()
        .out_dir("src/rust_grpc")
        .compile(&["proto/hello.proto"], &["proto"])?;

    // 3.生成mod.rs文件
    // 用下面的rust方式生成mod.rs
    let proto_ext = OsStr::new("proto");
    let ext: Option<&OsStr> = Some(&proto_ext);
    let mut mod_file = fs::OpenOptions::new()
        .write(true)
        .create(true)
        .open("src/rust_grpc/mod.rs")
        .expect("create mod.rs failed");
    let header = String::from("// @generated by protoc-gen-rust.Do not edit it!!!\n");
    let _ = mod_file.write(header.as_bytes());
    for file in &file_list.iter().next() {
        if file.extension().eq(&ext) {
            // 拓展名是proto的写入mod.rs中
            if let Some(file) = file.file_name() {
                let filename = file.to_str().unwrap();
                let filename = filename.replace(".proto", "");
                println!("current filename: {}", filename);
                let _ = mod_file.write(format!("pub mod {};\n", filename).as_bytes());
            }
        }
    }

    Ok(())
}
